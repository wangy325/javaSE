# 方法

> 1. 方法的声明和调用
> 2. return 关键字
> 3. 方法的重载(覆写)
> 4. 递归
> 5. Java 内存分析
> 6. 方法参数的传递

## 6.1 定义

​	方法：具体对象的行为；生活中的例子，如：狗能吃狗粮，"吃"就是狗具体的行为。在Java中我们叫做方法或函数

### 方法中的参数                              

​	方法中的参数：该方法在执行时所需要的数据。生活中的例子，如：业务员办理贷款，你所需要提供的资料。

* 数据类型可以有多种，就好比如你办理贷款需要提供的材料有多种
* *方法中的参数可以有多个*

## 6.2 方法的声明和调用

### 6.2.1 声明方法的格式

```java
[访问修饰符]   返回值类型  方法名 (参数类型 参数名1,…) {
    // 这里放方法的具体实现语句
}
```

*示例代码：*

```java
public class Student {
//访问修饰符  返回值  方法名 (参数类型 参数名，...)   //形式参数
	public void setName(String name){
      	//代码块
		System.out.println("将名字修改为："+name);
	}
}
```

### 6.2.2 调用方法的格式

```java
对象.方法名(实参列表);
```

*示例代码：*

```java
Student stu = 	new Student();		
stu.setName("张三");
```

### 6.2.3 方法的返回值

—方法的返回值，就是一个行为的结果—

### 6.2.4 return 关键字

return用于方法，两个作用：

   （1） 返回方法指定类型的值（这个值总是确定的），也可以是对象
   （2）方法的结束

两种形式：（1）有返回类型 例如：`return i;`

​                    （2）无返回类型  return;一般方法前有`void`代表无返回值，反之

```java
public class TestReturn { 
    public static void main(String args[]) { 
       TestReturn t = new TestReturn(); 
        t.test1(); 
        t.test2(); 
    } 
    /** 
     * 无返回值类型的return语句测试 
     */ 
    public void test1() { 
        System.out.println("---无返回值类型的return语句测试---"); 
        for (int i = 1; ; i++) { 
            if (i == 4){
                return; 
            } 
            System.out.println("i = " + i); 
        } 
    } 
    /** 
     * 有返回值类型的return语句测试 
     * @return String 
     */ 
    public String test2(){ 
        System.out.println("---------有返回值类型的return语句测试--------"); 
        return "返回一个字符串"; 
    } 
}
```

```
运行结果: 
---------无返回值类型的return语句测试-------- 
 i = 1 
 i = 2
 i = 3  
---------有返回值类型的return语句测试------- 
返回一个字符串  
```

## 6.3 方法的重载

> 方法名一定要相同
>
> 方法的参数表必须不同，包括参数的类型或个数，以此区分不同的方法体
>
> ​	1.如果参数个数不同，就不管它的参数类型了！
>
> ​	2.如果参数个数相同，那么参数的类型必须不同。
>
> 方法的返回类型、修饰符可以相同，也可不同

> 构造器(方法)的重载
>
> 注意：再调用重载的构造方法时候，this()必须放在构造方法的第一句代码...

*代码示例：*

```java
//如果某个构造方法的第一条语句具有形式this(...)，那么这个构造方法将调用本类中的其他构造方法
public class Employee {
    private String name;//姓名
    private int age;//年龄
    private double salary;//薪水
    
	public Employee(String name, double salary){//重载构造方法1
        this.name = name;//使用this,访问成员属性
        this.salary = salary;
    }
 	public Employee(String name, int age, double salary){//重载构造方法2
       	this(name,salary);//调用了重载构造方法1，(必须放在第一句)
        this.age = age;
    }
    public Employee(){//重载构造方法3
        this(“无名”, 18, 800.0);//调用到了重载构造方法2(必须放在第一句)
      	System.out.println("只能放在this()后面");
    }
}
// 注意：
// 1、调用本类其他构造方法的语句，即this(参数)语句，必须放在的该构造方法的第一行
```

## 6.4 递归算法

### 6.4.1 含义

递归算法是一种直接或间接地调用自身的算法。在计算机编写程序中，递归算法对解决一大类问题是十分有效的，它往往使算法的描述简洁而*且易于理解*

### 6.4.2 举例

*99乘法表的例子* 

1.    普通实现99乘法表太简单，是个程序员都会，实现如下：

      ```java
      public class Test99 {  
      	public static void main(String[] args) {	  
      		for(int i=1; i<=9;i++){
      			for(int j=1; j<=i; j++){
      				System.out.print(j+" * "+i+ " = "+(i*j)+"\t");
      			}
      			System.out.println();
      		}
      	}
      }
      ```

2. 用递归方式实现 99乘法表

      ```java
      public class Test99 {
         public static void main(String args[]) { 
             m(9); 
         }
                                                	  
      /** 
      * 打印出九九乘法表 
      * @param i 
       */
      public static void m(int i) { 
      	if (i >= 1) { 
      	m(i - 1); 
      	for (int j = 1; j <= i; j++) { 
      	System.out.print(j + "*" + i + "=" + j * i + " "); 
      	}
      	System.out.println(); 	
      	} 
        else
          return;
      }
      ```


递归的方式调用图示：

![](http://ojx4zwltq.bkt.clouddn.com/17-2-2/60055892-file_1486050546705_6d77.png)

每一个方法的调用都会产生一个栈帧，压入到方法栈，当递归调用的时候，方法栈中栈帧的图示和上图类似。
去掉方法中栈帧的引用关系更加直观：如下图所示：

![](http://ojx4zwltq.bkt.clouddn.com/17-2-2/64868162-file_1486050612176_1504c.png)

> 注意：
>
> 嵌套for循环 和  用递归实现 的比较:
>
> 栈主要是用来存放栈帧的，每执行一个方法就会出现压栈操作，所以采用递归的时候产生的栈帧比较多，递归就会影响到内存，非常消耗内存，而使用for循环就执行了一个方法，压入栈帧一次，只存在一个栈帧，所以比较节省内存

**总结：**实际开发根据需求使用，不能盲目的使用递归，否则有可能出现栈溢出...`Java.lang.StackOverflowError`

*练习：*给定一个数值，计算出它的阶乘值，例如5的阶乘为5×4×3×2×1；使用递归实现

```java
public class Demo02 {
    public static void main(String[] args) {
        System.out.println(fact(4 ));
    }

    private static int fact(int i) {
        if(i < 0 )
            return -1;
        if (i == 1 || i == 0)
            return 1;
        else
            return i * fact(i - 1);
    }
}
```

## 6.5可变参数列表

可变参数是jdk1.5增加的新特性

当定义方法时，传入的方法的参数个数不固定时，可以考虑使用可变参数

```java
/**
 * 求传入的所有整数的和
*/
public long sum(int... nums){
	long sum = 0;
	for(int num : nums){
		sum +=num;
	}
	return sum;
}
//调用
//直接传入长度不固定的整数来调用
long a = sum(8,9,4); 
long b = sum(5,9,0,8,9);
//由于在方法内部就是以数组的形式来访问，所以调用方法的时候也可以直接传入相应的数组
long c = sum(new int[]{4,5,6,7}); 
```

> 解释：
>
> 1. int... nums表示参数列表为可变参数
> 2. 在方法内部把可变参数**当作数组**来访问,所以调用方法的也可是传入数组
> 3. 定义方法的时候如果形参列表中除了可变参数，还有其他参数，则其他参数一定要放在可变参数的**之前**即：可变参数**只能是**形参列表中的最后一个参数
>
> 例如：
>
> - show(String str, int … num){};  //正确
> - show(String str, int … num, String s){}; //错误

## 6.6 Java的内存分析

**一般Java在内存分配时会涉及到以下区域：** 

1. 寄存器：我们在程序中无法控制 

2. 栈：

   1. 每个线程包含一个栈区，栈中只保存*基础数据类型*的对象和*自定义对象的引用*(不是对象)，其他对象都存放在堆区中 
   2. 每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问

3. 堆：

   1. 存储的全部是对象，每个对象都包含一个与之对应的class的信息(class的目的是得到操作指令) 
   2. jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身，即：存放用**new产生的数据** 

4. **方法区：方法区是系统分配的一个内存逻辑区域，是JVM在装载类文件时，用于存储类型信息的(类的描述信息)** 

   1. **Class的基本信息：**

      1. 每个类的**全限定名**

      2. 该类是类还是接口

      3. 该类型的访问修饰符

      等...

   2. **已装载的Class的详细信息**：

      1. 运行时**常量池**：在方法区中，每个类型都对应一个常量池，存放该类型所用到的所有常量，常量池中存储了诸如**文字字符串(String)**、final变量值、类名和方法名常量。它们以数组形式通过索引被访问，是外部调用与类联系及类型对象化的桥梁。*（存的可能是个普通的字符串，然后经过常量池解析，则变成指向某个类的引用）*
      2. 字段信息：字段信息存放类中声明的每一个字段的信息，包括字段的名、类型、修饰符。字段名称指的是类或接口的实例变量或类变量，字段的描述符是一个指示字段的类型的字符串，如private A a=null;则a为字段名，A为描述符，private为修饰符
      3. 方法信息：类中声明的每一个方法的信息，包括方法名、返回值类型、参数类型、修饰符、异常、方法的字节码。(在编译的时候，就已经将方法的局部变量、操作数栈大小等确定并存放在字节码中，在装载的时候，随着类一起装入方法区)

   3. 静态变量(**静态区**)：(*静态static*)

      * 类变量，类的所有实例都共享，我们只需知道，在方法区有个静态区，静态区专门存放静态变量和静态块

5. 非RAM存储：硬盘等永久存储空间 


> # **重点是堆、栈的存储**
>
> ### 堆，栈：
>
> 1. 函数中定义的一些**基本类型的数据变量**和**对象的引用变量**都在函数的栈内存中分配
>    栈的**优势**是存取速度比堆要快，仅次于直接位于CPU 的寄存器，而且数据可以共享
>    存在栈中的**数据大小与生存周期**必须是确定的。因此里面的变量通常是局部变量、函数参数等。 
>    当在一段代码块定义一个变量时（局部变量），Java就在**栈中** 为这个变量分配内存空间，当该变量所在的作用域结束后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用
> 2. **堆内存**用来存放由new创建的对象和数组。 在堆中分配的内存，由**Java虚拟机的自动垃圾回收器**来管理
>
> > 注意：在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的*引用变量*。
>
> 引用变量是普通的变量，定义时在栈中分配，引用变量在程序运行到其作用域之外后被释放。而数组和对象本身在堆中分配，即使程序 运行到使用 new 产生数组或者对象的语句所在的作用域之外，**数组和对象本身占据的内存不会被释放**，数组和对象在没有引用变量指向它的时候，才变为垃圾，不能再被使用，但仍然占据内存空间不放，在随后的一个不确定的时间被垃圾回收器收走（释放掉）
>
> * 栈：就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变量、函数参数等
> * 堆：就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序没有释放掉，那么在程序结束后，操作系统会自动回收

### Java中数据在内存中是如何存储的

### a. 基本数据类型

Java的基本数据类型共有8种，即int,short,long,byte,float,double,boolean,char(*注意，并没有String的基本类型* )。这种类型的定义是通过诸如int a = 3；long b = 255L；的形式来定义的。如int a = 3；这里的a是一个指向int类型的引用，指向3这个字面值。这些字面值的数据，由于大小可知，生存期可知(这些字面值定义在某个程序块里面，程序块退出后，字段值就消失了)，出于追求速度的原因，就存在于栈中

另外，栈有一个很重要的特殊性，就是存在*栈中的数据可以共享*。比如：
我们同时定义：

```java
int a=3;
int b=3;
```

编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找有没有字面值为3的地址，没找到，就开辟一个存放3这个字面值的地址，然后将a指向3的地址。接着处理int b = 3；在创建完b这个引用变量后，由于在栈中已经有3这个字面值，便将b直接指向3的地址。这样，就出现了a与b同时均指向3的情况。

定义完a与b的值后，再令a = 4；那么，b不会等于4，还是等于3。在编译器内部，遇到时，它就会重新搜索栈中是否有4的字面值，如果没有，重新开辟地址存放4的值；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。

### b. 对象

在Java中，创建一个对象包括对象的声明和实例化两步，下面用一个例题来说明对象的内存模型。假设有类Rectangle定义如下：

```java
public class Rectangle {
  double width;
  double height;
  public Rectangle( double w, double h){
      w = width;
      h = height;
  }
}
```

### (1)声明对象时的内存模型

用Rectangle rect；声明一个对象rect时，将在栈内存为对象的引用变量rect分配内存空间，但Rectangle的值为空，称rect是一个空对象。空对象不能使用，因为它还没有引用任何”实体”。

### (2)对象实例化时的内存模型

当执行rect=new Rectangle(3,5)；时，会做两件事：在堆内存中为类的成员变量width,height分配内存，并将其初始化为各数据类型的默认值；接着进行显式初始化（类定义时的初始化值）；最后调用构造方法，为成员变量赋值。返回堆内存中对象的引用（相当于首地址）给引用变量rect,以后就可以通过rect来引用堆内存中的对象了。

### c. 创建多个不同的对象实例

一个类通过使用new运算符可以创建多个不同的对象实例，这些对象实例将在堆中被分配不同的内存空间，改变其中一个对象的状态不会影响其他对象的状态。例如：

```
Rectangle r1= new Rectangle(3,5);
Rectangle r2= new Rectangle(4,6);
```

此时，将在堆内存中分别为两个对象的成员变量 width 、 height 分配内存空间，两个对象在堆内存中占据的空间是互不相同的。如果有：

```
Rectangle r1=new Rectangle(3,5);
Rectangle r2=r1;
```

则在堆内存中只创建了一个对象实例，在栈内存中创建了两个对象引用，两个对象引用同时指向一个对象实例。

而一个对象引用变量修改了这个对象的内部状态，会影响到另一个对象引用变量。



Java中常见的存储机制

1. 寄存器：

   这是最快的存储区，因为它位于处理器内部，数量极其有限，所以寄存器根据需求进行分配，你不能直接控制，也不能在程序中感觉到寄存器存在的任何迹象。

2. 栈(堆栈)：

   位于通用RAM【random-access-memory】[随机存取存储器]中，但通过堆栈指针可以直接从处理器那里得到支持，堆栈指针若向下移动，则分配新的内存，若向上移动，则释放那些内存。这是一种快速有效的分配存储方法，仅次于寄存器。创建程序时，Java系统必须知道存储在堆栈内所有项的确切生命周期，以便上下移动堆栈指针。这一约束限制了程序的灵活性。

3. 堆：一种通用的内存池（也位于RAM）中，用于存放所有Java对象。堆不同于堆栈的地方是：堆不需要知道存储的数据在堆里存活多长时间。因此，在堆里分配存储空间有很大的灵活性。当需要一个对象时，只需要用new写一行简单的代码，当执行这行代码时，会自动在堆里进行存储分配。缺点是用堆进行存储分配和清理要比用堆栈更耗时。

4. 常量存储区(方法区)：

   常量值一般直接放于程序内部，这样做是安全的，因为它们永远不可能改变。如果是嵌入式，可能常量本身会和程序分开，放在ROM中。

5. 非RAM存储如果数据完全存活于程序之外，那么它可以不受任何程序的影响。比如流对象和持久化对象。


## 6.7 对象的实例化内存分析

```java
Person p; 
p = new Person();
```


【内存分析】

 Java 中所说的地址值是 Java虚拟机计算出来的值，而并非真正的内存地址，这点跟C语句不一样，C语句是可以指向内存地址的。

对象的声明发生在栈空间之中，此时只是声明了一个引用类型的变量 p，（注意类类型的变量都属于引用型变量，类似String S )，而 p变量此时尚未保存任何数值，或者说 p 为空对象即 null，通过 new 运算符和类的构造方法为声明的对象分配成员变量。（详情参考如下)：

1. 成员变量在堆的GC*(garbage collection 垃圾回收)*区分配空间，执行构造器语句。

2. new运算符为成员变量分配内存空间后将返回一个引用赋值给变量 p，确保这些成员变量能够通过 p 引用指向的地址可以访问。当然对象的声明和分配成员变量可以一个步骤完成。例如

   ```java
   Person p = new Person (); 
   ```

 为对象分配成员变量的内存过程：

1. 在堆的永久区检查类模板信息，如果没有则执行第二步加载类的模板信息，如内存中有类信息则不执行第二步。
2. 若没有，则加载类模板信息
3. 在堆的 GC区开辟合适的空间，保存类的成员变量。
4. 为类对象的属性赋值此时只是赋缺省的初始化值
5. 在栈内存中调用其构造器，并将构造器执行的结果值，赋值给类的成员变量。（类的方法调用发生在栈空间中，如果执行默认的构造器没有任何结果返回，此时类的成员变量依然是第4步的缺省的初始化值）
6. 在栈空间执行构造器并将执行的结果传递给堆空间的成员变量（将构造器执行的结果传递给堆空间的成员变量赋值操作）【this.name = name;】
7. 将堆空间的类成员变量的内存首地址传递给栈的引用变量 p，p 指向了类的这个实例化的对象，此时 p 可以称作 Person类的一个对象，并且可以使用 p.属性或者p.方法的形式访问对象的属性和方法。




## 6.7 方法参数的传递

Java方法中传递参数，不管任何数据类型，均是**值传递**：即传递的是该变量所存储的值

### 6.7.1参数类型：基本数据类型

基本数据类型按值传递，相当于复制了一份过去！

下面我们就通过内存模型的方式来讨论一下Java中的参数传递。

这里的内存模型涉及到两种类型的内存：栈内存(stack)和堆内存(heap)。基本类型作为参数传递时，传递的是这个值的拷贝。无论你怎么改变这个拷贝，原值是不会改变的。看下边的一段代码，然后结合内存模型来说明问题：

```java
public class ParameterTransfer {
     public static void main(String[] args) {
        int num = 30;
        System.out.println("调用add方法前num=" + num);
        add(num);
        System.out.println("调用add方法后num=" + num);
     }
  
     public static void add(int param) {
          param = 100;
     }
}              
```

这段代码运行的结果如下：

```
调用add方法前num=30
调用add方法后num=30
```

程序运行的结果也说明这一点，无论你在add()方法中怎么改变参数param的值，原值num都不会改变。

　　下边通过内存模型来分析一下。

　　当执行了int num = 30;这句代码后，程序在**栈**内存中开辟了一块地址为AD8500的内存，里边放的值是30，内存模型如下图：

![](http://s10.sinaimg.cn/middle/59ca2c2aga225b4214c29&690?_=4311863)

执行到add()方法时，程序在栈内存中又开辟了一块地址为AD8600的内存，将num的值30传递进来，此时这块内存里边放的值是30，执行param = 100;后，AD8600中的值变成了100。内存模型如下图：   

![](http://s5.sinaimg.cn/middle/59ca2c2aga225cb1985e4&690?_=4311863)

地址AD8600中用于存放param的值，和存放num的内存没有任何关系，无论你怎么改变param的值，实际改变的是地址为AD8600的内存中的值，而AD8500中的值并未改变，所以num的值也就没有改变。

### 6.7.2参数类型：引用数据类型

引用数据按地址传递，两个地方根据地址使用同一份数据，如被更改，则原有数据也会更改，例如数组，在传递数组时，如果接收到数组之后，对其修改，那么原来的数组也会同时修改，因为它们指向同一个地址！

```java
public class ParameterTransfer {
     public static void main(String[] args) {
          String[] array = new String[] {"huixin"};
          System.out.println("调用reset方法前array中的第0个元素的值是:" + array[0]);
          reset(array);
          System.out.println("调用reset方法后array中的第0个元素的值是:" + array[0]);
     }
  
     public static void reset(String[] param) {
          param[0] = "hello, world!";
     }
}   
```

运行的结果如下：

```
调用reset方法前array中的第0个元素的值是:huixin
调用reset方法后array中的第0个元素的值是:hello, world!
```

当对象作为参数传递时，传递的是对象的引用，也就是对象的地址。下边用内存模型图来说明：

![](http://s15.sinaimg.cn/middle/59ca2c2aga239181b361e&690?_=4311863)



程序执行了String[] array = new String[] {"huixin"}后，程序在栈内存中开辟了一块地址编号为AD9500内存空间，用于存放array[0]的引用地址，里边放的值是堆内存中的一个地址，示例中的值为BE2500，可以理解为有一个指针指向了堆内存中的编号为BE2500的地址。堆内存中编号为BE2500的这个地址中存放的才是array[0]的值：huixin。

　　当程序进入reset方法后，将array的值，也就是对象的引用BE2500传了进来。这时，程序在栈内存中又开辟了一块编号为AD9600的内存空间，里边放的值是传递过来的值，即AD9600。可以理解为栈内存中的编号为AD9600的内存中有一个指针，也指向了堆内存中编号为BE2500的内存地址，如图所示：

![](http://s2.sinaimg.cn/middle/59ca2c2aga23937aec541&690?_=4311863)

这样一来，栈内存AD9500和AD9600(即array[0]和param的值)都指向了编号为BE2500的堆内存。

在reset方法中将param的值修改为hello, world!后，内存模型如下图所示：

![](http://s3.sinaimg.cn/middle/59ca2c2aga2394a416762&690?_=4311863)

改变对象param的值实际上是改变param这个栈内存所指向的堆内存中的值。param这个对象在栈内存中的地址是AD9600，里边存放的值是BE2500，所以堆内存BE2500中的值就变成了hello,world!。程序返回main方法之后，堆内存BE2500中的值仍然为hello,world!，main方法中array[0]的值时，从栈内存中找到array[0]的值是BE2500，然后去堆内存中找编号为BE2500的内存，里边的值是hello,world!。所以main方法中打印出来的值就变成了hello,world!

**小结：**

　　无论是基本类型作为参数传递，还是对象作为参数传递，**实际上传递的都是值，只是值的的形式不用而已**。第一个示例中用基本类型作为参数传递时，将栈内存中的值30传递到了add方法中。第二个示例中用对象作为参数传递时，将栈内存中的值BE2500传递到了reset方法中。当用对象作为参数传递时，真正的值是放在堆内存中的，传递的是栈内存中的值，而栈内存中存放的是堆内存的地址，所以传递的就是堆内存的地址。这就是它们的区别。

补充一下，在Java中，**String是一个引用类型**，但是在作为参数传递的时候**表现出来的却是基本类型的特性**，即在方法中改变了String类型的变量的值后，不会影响方法外的String变量的值。


# 作业

1. 创建一个学生类Student

   * 为其添加三个属性 id name sex

   * 编写一个方法show()使用this关键字显示出学生的所有信息
   * 为学生类加入一个静态的属性address
   * 创建两个学生对象，分别为address赋值。看其变化

     ​


2. 编写一个手机类Phone
   * 属性：品牌，系统,电池
   * 为类添加合适的构造方法
   * 行为：
     * 播放音乐 
     * 下载音乐
     * 给电池充电

3. 编写一个Calculator类，该类拥有方法addition，该方法可以传入 1 至多个数值类型参数(可以是int,float,double)。并在该方法实现对传入进来的数值进行叠加后，作为返回值返回。

4. 编写一个班级类 Class1701，以及学生类Student

   1. 学生类：
      1. 属性：名字name(String)，年龄age(int)，性别sex(char)
      2. 添加适当的构造方法
      3. 方法：修改名字changeName，修改年龄changeAge，修改性别changeSex，显示学生信息showInfo

   * 班级类：
     * 属性：有42个学生的容量，Student[] stus = new Student[42];。
     * 添加适当的构造方法
     * 方法：
       * 添加完整的学生信息  addStudent(Student stu)
       * 添加学生信息，只有名字 addStudent(String name)
       * 添加学生信息，只有名字和年龄 addStudent(String name,int age)
       * 添加学生信息，有名字和年龄和性别 addStudent(String name,int age,char sex)
       * 修改学生信息 updateStudent(Student stu,String name);//参数二为需要修改的学生的姓名
       * 控制台输出所有学生的信息 printAllStudentInfo()。

   ​


